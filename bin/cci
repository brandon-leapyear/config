#!/usr/bin/env python3

"""
Access the Circle CI API.

Follow instructions to get API token: https://circleci.com/docs/api/#authentication
"""

import argparse
import json
import re
import requests
import os
from warnings import warn

# Regex patterns
ANSI_ESCAPE = re.compile(r'\x1b.*?m')
PREFIX = re.compile(r'^(?:{})?'.format(ANSI_ESCAPE.pattern))

def main():
    args = get_parser().parse_args()

    def query(path):
        url = f'https://circleci.com/api/v1.1/{path}'
        r = requests.get(url, auth=(args.token, ''))
        return r.json()

    def query_project(path):
        return query(f'project/github/{args.repo}/{path}')

    if args.command is None:
        response = query('me')
        dump(response)
    elif args.command == 'get-failure':
        response = query_project(f'{args.num}')
        get_failure(args, response)
    else:
        raise Exception

def get_parser():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__,
    )
    parser.add_argument(
        '--repo', '-r',
        default=os.environ.get('CIRCLE_REPO'),
        help='Circle CI repo to query; e.g. `LeapYear/leapyear` (defaults to $CIRCLE_REPO)',
    )
    parser.add_argument(
        '--token', '-t',
        default=os.environ.get('CIRCLE_TOKEN'),
        help='Circle CI API Token (defaults to $CIRCLE_TOKEN)',
    )
    subparsers = parser.add_subparsers(dest='command')

    get_failure = subparsers.add_parser(
        'get-failure',
        help='Gets the output for a job failure',
    )
    get_failure.add_argument(
        'num',
        type=int,
        help='The job number to query',
    )
    get_failure.add_argument(
        '--output', '-o',
        help='Store the output to the given file',
    )
    get_failure.add_argument(
        '-O',
        dest='output_default',
        action='store_true',
        help='Store the output to a file named `circleci-job-NUM.txt`',
    )
    get_failure.add_argument(
        '--prefix',
        help='Filter output to only include lines that start with the given regex (stripping the match)',
    )

    return parser

def dump(obj, **kwargs):
    kwargs.setdefault('indent', 4)
    print(json.dumps(obj, **kwargs))

def get_failure(args, response):
    failed = []
    for step in response['steps']:
        action = step['actions'][0]
        if action['failed']:
            failed.append(action)

    if len(failed) == 0:
        raise Exception('No steps failed in this build')
    else:
        failure = failed[0]
        if len(failed) > 1:
            warn(f'Multiple failures found. Using the failure at step: {failure["name"]}')
        else:
            print(f'Failure found at step: {failure["name"]}')

    output_url = failure['output_url']
    r = requests.get(output_url)
    message = None
    for output in json.loads(r.content):
        if output['type'] == 'out':
            message = output['message']

    # clean circle ci's backspace characters
    message = re.sub(r'.*\x08(.*)', r'\1', message)

    if args.prefix:
        message = '\n'.join(
            match.expand(r'\1')
            for match in re.finditer(PREFIX.pattern + args.prefix + r'\s?(.*)$', message, re.MULTILINE)
        )

    if args.output or args.output_default:
        dest = args.output or f'circleci-job-{args.num}.txt'
        print(f'Writing output to: {dest}')
        # clean ANSI escape codes
        message = ANSI_ESCAPE.sub('', message)
        open(dest, 'w').write(message)
    else:
        print(message)

if __name__ == '__main__':
    main()
